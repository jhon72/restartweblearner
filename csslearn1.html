<!DOCTYPE html>
    <html>
        <head>
            <title>ResWebLearn72</title>
                <meta charset="utf-8">
                <link rel="stylesheet" href="css/navbar.css">
                <link rel="stylesheet" href="css/footer.css">
                <link rel="stylesheet" href="css/content.css">
                <link rel="stylesheet" href="css/other.css">
                <link href='https://fonts.googleapis.com/css?family=Roboto:500,900,100,300,700,400' rel='stylesheet' type='text/css'>
            <style>body{background: url(img/fon.png);}</style>
        <nav class="blend">
       <ul>
     <div class="hdr">
	   <span>R</span><span>e</span><span>s</span><span>W</span><span>e</span><span>b</span> <div><span>L</span><span>e</span><span>a</span><span>r</span><span>n</span><span>7</span><span>2</span></div></div><br>
      <li><a href="index.html">Главная</a></li>
      <li><a href="openserver.html">Open Server</a></li>
      <li><a class="active" href="htmlandcss.html">HTML5 & CSS3</a></li>
      <li><a href="javascript.html">JavaScript</a></li>
      <li><a href="jquery.html">Jquery</a></li>
      <li><a href="mysql.html">MySQL</a></li>
      <li><a href="php.html">PHP</a></li>
      <li><a href="contacts.html">Контакты</a></li></ul></nav><br><br><br><br><br><br><br><br><br><br><br><br><body>
      
      
      
      <div class="container">
    <div class="bubble">
                        <div class="info">
                        
                        
                        <h2>Основы CSS</h2>
                        
                        <strong>CSS (Cascading Style Sheets), или каскадные таблицы стилей</strong>, используются для описания внешнего вида документа, написанного языком разметки. Обычно CSS-стили используются для создания и изменения стиля элементов веб-страниц и пользовательских интерфейсов, написанных на языках HTML и XHTML, но также могут быть применены к любому виду XML-документа, в том числе XML, SVG и XUL. </p>
<p>Каскадные таблицы стилей описывают правила форматирования элементов с помощью свойств и допустимых значений этих свойств. Для каждого элемента можно использовать ограниченный набор свойств, остальные свойства не будут оказывать на него никакого влияния.</p>
<p>Объявление стиля состоит из двух частей: элемента веб-страницы &#8212; <strong>селектора</strong>, и команды форматирования &#8212; <strong>блока объявления</strong>. Селектор сообщает браузеру, какой именно элемент форматировать, а в блоке объявления (код в фигурных скобках) перечисляются форматирующие команды &#8212; свойства и их значения.</p>

<h2>Виды каскадных таблиц стилей и их специфика</h2>
<ul class="contents">
<li style="color:white; background:#688cdd;">Содержание:</li>
<li><a href="#part1">1. Виды таблиц стилей</a></li>
<li><a href="#part2">2. Виды селекторов</a></li>
<li><a href="#part3">3. Комбинация селекторов</a></li>
<li><a href="#part4">4. Группировка селекторов</a></li>
<li><a href="#part5">5. Наследование и каскад</a></li>
</ul>
<h3 id="part1">1. Виды таблиц стилей</h3>
<h4>1.1. Внешняя таблица стилей</h4>
<p><strong>Внешняя таблица стилей</strong> представляет собой текстовый файл с расширением <kbd>.css</kbd>, в котором находится набор CSS-стилей элементов. Файл создаётся в редакторе кода, так же как и HTML-страница. Внутри файла могут содержатся только стили, без HTML-разметки. Внешняя таблица стилей подключается к веб-странице с помощью тега <kbd>&lt;link&gt;</kbd>, расположенного внутри раздела <kbd>&lt;head&gt;&lt;/head&gt;</kbd>. Такие стили работают для всех страниц сайта. </p>
<p>К каждой веб-странице можно присоединить несколько таблиц стилей, добавляя последовательно несколько тегов <kbd>&lt;link&gt;</kbd>, указав в атрибуте тега <kbd>media</kbd> назначение данной таблицы стилей. <kbd>rel="stylesheet"</kbd> указывает тип ссылки (ссылка на таблицу стилей).</p>
<pre class="lang:default decode:true " >&lt;head&gt;
&lt;link rel="stylesheet" href="css/style.css"&gt;
&lt;link rel="stylesheet" href="css/assets.css" media="all"&gt;
&lt;/head&gt;</pre>
<p>Атрибут <kbd>type="text/css"</kbd> не является обязательным по стандарту HTML5, поэтому его можно не указывать. Если атрибут отсутствует, по умолчанию используется значение <kbd>type="text/css"</kbd>.</p>
<h4>1.2. Внутренние стили</h4>
<p><strong>Внутренние стили</strong> встраиваются в раздел <kbd>&lt;head&gt;&lt;/head&gt;</kbd> HTML-документа и определяются внутри тега <kbd>&lt;style&gt;&lt;/style&gt;</kbd>. Внутренние стили имеют приоритет над внешними, но уступают встроенным стилям (заданным через атрибут <kbd>style</kbd>). </p>
<pre class="lang:default decode:true " >&lt;head&gt;
&lt;style&gt;
h1, 
h2 {
color: red;
font-family: "Times New Roman", Georgia, Serif;
line-height: 1.3em;
}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
...
&lt;/body&gt;</pre>
<h4>1.3. Встроенные стили</h4>
<p>Когда мы пишем <strong>встроенные стили</strong>, мы пишем CSS-код в HTML-файл, непосредственно внутри тега элемента с помощью атрибута <kbd>style</kbd>:</p>
<pre class="lang:default decode:true " >&lt;p style="font-weight: bold; color: red;"&gt;Обратите внимание на этот текст.&lt;/p&gt;</pre>
<p>Такие стили действуют только на тот элемент, для которого они заданы.</p>
<h4 id="import">1.4. Правило @import</h4>
<p><b>Правило <kbd>@import</kbd></b> позволяет загружать внешние таблицы стилей. Чтобы директива <kbd>@import</kbd> работала, она должна располагаться в таблице стилей (внешней или внутренней) перед всеми остальными правилами:</p>
<pre class="lang:default decode:true " >&lt;style&gt;
@import url(mobile.css);
p {
font-size: 0.9em; 
color: grey;
}
&lt;/style&gt;</pre>
<p>Правило <kbd>@import</kbd> также используется для подключения веб-шрифтов:</p>
<pre class="lang:css decode:true " >@import url(https://fonts.googleapis.com/css?family=Open+Sans&amp;subset=latin,cyrillic);</pre>
<h3 id="part2">2. Виды селекторов</h3>
<p><strong>Селекторы</strong> представляют структуру веб-страницы. С их помощью создаются правила для форматирования элементов веб-страницы. Селекторами могут быть элементы, их классы и идентификаторы, а также псевдоклассы и псевдоэлементы. </p>
<h4>2.1. Универсальный селектор</h4>
<p>Соответствует любому HTML-элементу. Например, <kbd>* {margin: 0;}</kbd> обнулит внешние отступы для всех элементов сайта. Также селектор может использоваться в комбинации с псевдоклассом или псевдоэлементом: <kbd>*:after {CSS-стили}</kbd>, <kbd>*:checked {CSS-стили}</kbd>.</p>
<h4>2.2. Селектор элемента</h4>
<p>Селекторы элементов позволяют форматировать все элементы данного типа на всех страницах сайта. Например, <kbd>h1 {font-family: Lobster, cursive;}</kbd> задаст общий стиль форматирования всех заголовков <kbd>h1</kbd>.</p>
<h4>2.3. Селектор класса</h4>
<p>Селекторы класса позволяют задавать стили для одного и более элементов с одинаковым именем класса, размещенных в разных местах страницы или на разных страницах сайта. Например, для создания заголовка с классом <kbd>headline</kbd> необходимо добавить атрибут <kbd>class</kbd> со значением <kbd>headline</kbd> в открывающий тег <kbd>&lt;h1&gt;</kbd> и задать стиль для указанного класса. Стили, созданные с помощью класса, можно применять к другим элементам, не обязательно данного типа.</p>
<pre>&lt;h1 class="headline"&gt;Инструкция пользования персональным компьютером&lt;/h1&gt;</pre>
<pre class="lang:css decode:true " >.headline {
text-transform: uppercase; 
color: lightblue;
}</pre>
<h4>2.4. Селектор идентификатора</h4>
<p>Селектор идентификатора позволяет форматировать <b>один</b> конкретный элемент. Идентификатор <kbd>id</kbd> должен быть уникальным и на одной странице может встречаться только один раз.</p>
<pre>&lt;div id="sidebar"&gt;&lt;/div&gt;</pre>
<pre class="lang:css decode:true " >#sidebar {
width: 300px; 
float: left;
}</pre>
<h4>2.5. Селектор потомка</h4>
<p>Селекторы потомков применяют стили к элементам, расположенным внутри элемента-контейнера. Например, <kbd>ul li {text-transform: uppercase;}</kbd> &#8212; выберет все элементы <kbd>li</kbd>, являющиеся потомками всех элементов <kbd>ul</kbd>.</p>
<p>Если нужно отформатировать потомки определенного элемента, этому элементу нужно задать стилевой класс:</p>
<p><kbd>p.first a {color: green;}</kbd> &#8212; данный стиль применится ко всем ссылкам, потомкам абзаца с классом <kbd>first</kbd>; </p>
<p><kbd>p .first a {color: green;}</kbd> &#8212; если добавить пробел, то будут стилизованы ссылки, расположенные внутри любого тега класса <kbd>.first</kbd>, который является потомком элемента <kbd>&lt;p&gt;</kbd>;</p>
<p><kbd>.first a {color: green;}</kbd> &#8212; данный стиль применится к любой ссылке, расположенной внутри другого элемента, обозначенного классом <kbd>.first</kbd>.</p>
<h4>2.6. Дочерний селектор</h4>
<p>Дочерний элемент является прямым потомком содержащего его элемента. У одного элемента может быть несколько дочерних элементов, а родительский элемент у каждого элемента может быть только один. Дочерний селектор позволяет применить стили только если дочерний элемент идёт сразу за родительским элементом и между ними нет других элементов, то есть дочерний элемент больше ни во что не вложен.<br />
Например, <kbd>p > strong</kbd> &#8212; выберет все элементы <kbd>strong</kbd>, являющиеся дочерними по отношению к элементу <kbd>p</kbd>.</p>
<h4>2.7. Сестринский селектор</h4>
<p>Сестринские отношения возникают между элементами, имеющими общего родителя. Селекторы сестринских элементов позволяют выбрать элементы из группы элементов одного уровня. </p>
<p><kbd>h1 + p</kbd> &#8212; выберет все первые абзацы, идущие непосредственно за любым тегом <kbd>&lt;h1&gt;</kbd>, не затрагивая остальные абзацы;</p>
<p><kbd>h1 ~ p</kbd> &#8212; выберет все абзацы, являющиеся сестринскими по отношению к любому заголовку <kbd>h1</kbd> и идущие сразу после него.</p>
<h4>2.8. Селектор атрибута</h4>
<p>Селекторы атрибутов выбирают элементы на основе имени атрибута или значения атрибута:</p>
<p><kbd>[атрибут]</kbd> &#8212; все элементы, содержащие указанный атрибут, <kbd>[alt]</kbd> &#8212; все элементы, для которых задан атрибут <kbd>alt</kbd>;</p>
<p><kbd>селектор[атрибут]</kbd> &#8212; элементы данного типа, содержащие указанный атрибут, <kbd>img[alt]</kbd> &#8212; только картинки, для которых задан атрибут <kbd>alt</kbd>;</p>
<p><kbd>селектор[атрибут="значение"]</kbd> &#8212; элементы данного типа, содержащие указанный атрибут с конкретным значением, <kbd>img[title="flower"]</kbd> &#8212; все картинки, название которых содержит слово <kbd>flower</kbd>;</p>
<p><kbd>селектор[атрибут~="значение"]</kbd> &#8212; элементы частично содержащие данное значение, например, если для элемента задано несколько классов через пробел, <kbd>p[class~="feature"]</kbd> &#8212; абзацы, имя класса которых содержит <kbd>feature</kbd>;</p>
<p><kbd>селектор[атрибут|="значение"]</kbd> &#8212; элементы, список значений атрибута которых начинается с указанного слова, <kbd>p[class|="feature"]</kbd> &#8212; абзацы, имя класса которых <kbd>feature</kbd> или начинается на <kbd>feature</kbd>;</p>
<p><kbd>селектор[атрибут^="значение"]</kbd> &#8212; элементы, значение атрибута которых начинается с указанного значения, <kbd>a[href^="http://"]</kbd> &#8212; все ссылки, начинающиеся на <kbd>http://</kbd>;</p>
<p><kbd>селектор[атрибут$="значение"]</kbd> &#8212; элементы, значение атрибута которых заканчивается указанным значением, <kbd>img[src$=".png"]</kbd> &#8212; все картинки в формате <kbd>png</kbd>;</p>
<p><kbd>селектор[атрибут*="значение"]</kbd> &#8212; элементы, значение атрибута которых содержит в любом месте указанное слово, <kbd>a[href*="book"]</kbd> &#8212; все ссылки, название которых содержит <kbd>book</kbd>.</p>
<h4>2.9. Селектор псевдокласса</h4>
<p>Псевдоклассы &#8212; это классы, фактически не прикрепленные к HTML-тегам. Они позволяют применить CSS-правила к элементам при совершении события или подчиняющимся определенному правилу. Псевдоклассы характеризуют элементы со следующими свойствами:</p>
<p><kbd>:link</kbd> &#8212; не посещенная ссылка;</p>
<p><kbd>:visited</kbd> &#8212; посещенная ссылка;</p>
<p><kbd>:hover</kbd> &#8212; любой элемент, по которому проводят курсором мыши;</p>
<p><kbd>:focus</kbd> &#8212; интерактивный элемент, к которому перешли с помощью клавиатуры или активировали посредством мыши;</p>
<p><kbd>:active</kbd> &#8212; элемент, который был активизирован пользователем;</p>
<p><kbd>:valid</kbd> &#8212; поля формы, содержимое которых прошло проверку в браузере на соответствие указанному типу данных;</p>
<p><kbd>:invalid</kbd> &#8212; поля формы, содержимое которых не соответствует указанному типу данных;</p>
<p><kbd>:enabled</kbd> &#8212; все активные поля форм;</p>
<p><kbd>:disabled</kbd> &#8212; заблокированные поля форм, т.е., находящиеся в неактивном состоянии;</p>
<p><kbd>:in-range</kbd> &#8212; поля формы, значения которых находятся в заданном диапазоне;</p>
<p><kbd>:out-of-range</kbd> &#8212; поля формы, значения которых не входят в установленный диапазон;</p>
<p><kbd>:lang()</kbd> &#8212; элементы с текстом на указанном языке;</p>
<p><kbd>:not(селектор)</kbd> &#8212; элементы, которые не содержат указанный селектор &#8212; класс, идентификатор, название или тип поля формы &#8212; <kbd>:not([type="submit"])</kbd>;</p>
<p><kbd>:target</kbd> &#8212; элемент с символом <kbd>#</kbd>, на который ссылаются в документе;</p>
<p><kbd>:checked</kbd> &#8212; выделенные (выбранные пользователем) элементы формы.</p>
<h4>2.10. Селектор структурных псевдоклассов</h4>
<p>Структурные псевдоклассы отбирают дочерние элементы в соответствии с параметром, указанным в круглых скобках:</p>
<p><kbd>:nth-child(odd)</kbd> &#8212; нечётные дочерние элементы;</p>
<p><kbd>:nth-child(even)</kbd> &#8212; чётные дочерние элементы;</p>
<p><kbd>:nth-child(3n)</kbd> &#8212; каждый третий элемент среди дочерних;</p>
<p><kbd>:nth-child(3n+2)</kbd> &#8212; выбирает каждый третий элемент, начиная со второго дочернего элемента <kbd>(+2)</kbd>;</p>
<p><kbd>:nth-child(n+2)</kbd> &#8212; выбирает все элементы, начиная со второго;</p>
<p><kbd>:nth-child(3)</kbd> &#8212; выбирает третий дочерний элемент;</p>
<p><kbd>:nth-last-child()</kbd> &#8212; в списке дочерних элементов выбирает элемент с указанным местоположением, аналогично с <kbd>:nth-child()</kbd>, но начиная с последнего, в обратную сторону;</p>
<p><kbd>:first-child</kbd> &#8212; позволяет оформить только самый первый дочерний элемент тега;</p>
<p><kbd>:last-child</kbd> &#8212; позволяет форматировать последний дочерний элемент тега;</p>
<p><kbd>:only-child</kbd> &#8212; выбирает элемент, являющийся единственным дочерним элементом;</p>
<p><kbd>:empty</kbd> &#8212; выбирает элементы, у которых нет дочерних элементов;</p>
<p><kbd>:root</kbd> &#8212; выбирает элемент, являющийся корневым в документе &#8212; элемент <kbd>html</kbd>.</p>
<h4>2.11. Селектор структурных псевдоклассов типа</h4>
<p>Указывают на конкретный тип дочернего тега:</p>
<p><kbd>:nth-of-type()</kbd> &#8212; выбирает элементы по аналогии с <kbd>:nth-child()</kbd>, при этом берёт во внимание только тип элемента; </p>
<p><kbd>:first-of-type</kbd> &#8212; выбирает первый дочерний элемент данного типа; </p>
<p><kbd>:last-of-type</kbd> &#8212; выбирает последний элемент данного типа;</p>
<p><kbd>:nth-last-of-type()</kbd> &#8212; выбирает элемент заданного типа в списке элементов в соответствии с указанным местоположением, начиная с конца;</p>
<p><kbd>:only-of-type</kbd> &#8212; выбирает единственный элемент указанного типа среди дочерних элементов родительского элемента.</p>
<h4 id="pseudo-elements">2.12. Селектор псевдоэлемента</h4>
<p>Псевдоэлементы используются для добавления содержимого, которое генерируется с помощью свойства <kbd>content</kbd>:</p>
<p><kbd>:first-letter</kbd> &#8212; выбирает первую букву каждого абзаца, применяется только к блочным элементам;</p>
<p><kbd>:first-line</kbd> &#8212; выбирает первую строку текста элемента, применяется только к блочным элементам;</p>
<p><kbd>:before</kbd> &#8212; вставляет генерируемое содержимое перед элементом;</p>
<p><kbd>:after</kbd> &#8212; добавляет генерируемое содержимое после элемента.</p>
<h3 id="part3">3. Комбинация селекторов</h3>
<p>Для более точного отбора элементов для форматирования можно использовать комбинации селекторов:</p>
<p><kbd>a[href][title]</kbd> &#8212; выберет все ссылки, для которых заданы атрибуты <kbd>href</kbd> и <kbd>title</kbd>;</p>
<p><kbd>img[alt*="css"]:nth-of-type(even)</kbd> &#8212; выберет все четные картинки, альтернативный текст которых содержит слово <kbd>css</kbd>.</p>
<h3 id="part4">4. Группировка селекторов</h3>
<p>Один и тот же стиль можно одновременно применить к нескольким элементам. Для этого необходимо в левой части объявления перечислить через запятую нужные селекторы:</p>
<pre class="lang:default decode:true " >h1, 
h2, 
p, 
span {
color: tomato; 
background: white;
}</pre>
<h3 id="part5">5. Наследование и каскад</h3>
<p>Наследование и каскад &#8212; два фундаментальных понятия в CSS, которые тесно связаны между собой. Наследование заключается в том, что элементы наследуют свойства от своего родителя (элемента, их содержащего). Каскад проявляется в том, как разные виды таблиц стилей применяются к документу, и как конфликтующие правила переопределяют друг друга.</p>
<h4>5.1. Наследование</h4>
<p><b>Наследование</b> является механизмом, с помощью которого определенные свойства передаются от предка к его потомкам. Спецификацией CSS предусмотрено наследование свойств, относящихся к текстовому содержимому страницы, таких как <kbd>color</kbd>, <kbd>font</kbd>, <kbd>letter-spacing</kbd>, <kbd>line-height</kbd>, <kbd>list-style</kbd>, <kbd>text-align</kbd>, <kbd>text-indent</kbd>, <kbd>text-transform</kbd>, <kbd>visibility</kbd>, <kbd>white-space</kbd> и <kbd>word-spacing</kbd>. Во многих случаях это удобно, так как не нужно задавать размер шрифта и семейство шрифтов для каждого элемента веб-страницы.</p>
<p>Свойства, относящиеся к форматированию блоков, не наследуются. Это <kbd>background</kbd>, <kbd>border</kbd>, <kbd>display</kbd>, <kbd>float</kbd> и <kbd>clear</kbd>, <kbd>height</kbd> и <kbd>width</kbd>, <kbd>margin</kbd>, <kbd>min-max-height</kbd> и <kbd>-width</kbd>, <kbd>outline</kbd>, <kbd>overflow</kbd>, <kbd>padding</kbd>, <kbd>position</kbd>, <kbd>text-decoration</kbd>, <kbd>vertical-align</kbd> и <kbd>z-index</kbd>. </p>
<h5>Принудительное наследование</h5>
<p>С помощью ключевого слова <kbd>inherit</kbd> можно принудить элемент наследовать любое значение свойства родительского элемента. Это работает даже для тех свойств, которые не наследуются по умолчанию.</p>
<h5>Как задаются и работают CSS-стили</h5>
<p>1) Стили могут наследоваться от родительского элемента (наследуемые свойства или с помощью значения <kbd>inherit</kbd>);</p>
<p>2) Стили, расположенные в таблице стилей ниже, отменяют стили, расположенные в таблице выше;</p>
<p>3) К одному элементу могут применяться стили из разных источников. Проверить, какие стили применяются, можно в режиме разработчика браузера. Для этого над элементом нужно щёлкнуть правой кнопкой мыши и выбрать пункт &#171;Посмотреть код&#187; (или что-то аналогичное). В правом столбце будут перечислены все свойства, которые заданы для этого элемента или наследуются от родительского элемента, а также файлы стилей, в которых они указаны, и порядковый номер строки кода.</p>

<p>4) При определении стиля можно использовать любую комбинацию селекторов &#8212; селектор элемента, псевдокласса элемента, класса или идентификатора элемента.</p>
<pre class="lang:default decode:true " >&lt;div id="wrap" class="box clear"&gt;&lt;/div&gt;</pre>
<pre class="lang:css decode:true " >div {border: 1px solid #eee;}
#wrap {width: 500px;}
.box {float: left;}
.clear {clear: both;}</pre>
<h4>5.2. Каскад</h4>
<p><b>Каскадирование</b> &#8212; это механизм, который управляет конечным результатом в ситуации, когда к одному элементу применяются разные CSS-правила. Существует три критерия, которые определяют порядок применения свойств &#8212; правило <kbd>!important</kbd>, специфичность и порядок, в котором подключены таблицы стилей.</p>
<h5>Правило !important</h5>
<p>Вес правила можно задать с помощью ключевого слова <kbd>!important</kbd>, которое добавляется сразу после значения свойства, например, <kbd>span {font-weight: bold!important;}</kbd>. Правило необходимо размещать в конец объявления перед закрывающей скобкой, без пробела. Такое объявление будет иметь приоритет над всеми остальными правилами. Это правило позволяет отменить значение свойства и установить новое для элемента из группы элементов в случае, когда нет прямого доступа к файлу со стилями.</p>
<h5>Специфичность</h5>
<p>Для каждого правила браузер вычисляет <strong>специфичность селектора</strong>, и если у элемента имеются конфликтующие объявления свойств, во внимание принимается правило, имеющее наибольшую специфичность. Значение специфичности состоит из четырех частей: <kbd>0, 0, 0, 0</kbd>. Специфичность селектора определяется следующим образом:</p>
<p><span class="first">для</span> <kbd>id</kbd> добавляется <kbd>0, 1, 0, 0</kbd>;<br />
<span class="first">для</span> <kbd>class</kbd> добавляется <kbd>0, 0, 1, 0</kbd>;<br />
<span class="first">для</span> каждого элемента и псевдоэлемента добавляется <kbd>0, 0, 0, 1</kbd>;<br />
<span class="first">для</span> встроенного стиля, добавленного непосредственно к элементу &#8212; <kbd>1, 0, 0, 0</kbd>;<br />
<span class="first">универсальный</span> селектор не имеет специфичности.</p>
<pre class="lang:css decode:true " >h1 {color: lightblue;} /*специфичность 0, 0, 0, 1*/
em {color: silver;} /*специфичность 0, 0, 0, 1*/
h1 em {color: gold;} /*специфичность: 0, 0, 0, 1 + 0, 0, 0, 1 = 0, 0, 0, 2*/
div#main p.about {color: blue;} /*специфичность: 0, 0, 0, 1 + 0, 1, 0, 0 + 0, 0, 0, 1 + 0, 0, 1, 0 = 0, 1, 1, 2*/
.sidebar {color: grey;} /*специфичность 0, 0, 1, 0*/
#sidebar {color: orange;} /*специфичность 0, 1, 0, 0*/
li#sidebar  {color: aqua;} /*специфичность: 0, 0, 0, 1 + 0, 1, 0, 0 = 0, 1, 0, 1*/</pre>
<p>В результате к элементу применятся те правила, специфичность которых больше. Например, если на элемент действуют две специфичности со значениями <kbd>0, 0, 0, 2</kbd> и <kbd>0, 1, 0, 1</kbd>, то выиграет второе правило.</p>
<h5>Порядок подключённых таблиц</h5>
<p>Вы можете создать несколько внешних таблиц стилей и подключить их к одной веб-странице. Если в разных таблицах будут встречаться разные значения свойств одного элемента, то в результате к элементу применится правило, находящееся в таблице стилей, идущей в списке ниже. </p>

                       <h2>Блочные и строчные элементы</h2>      
                       
                              
                                     <p>Выделяют две основные категории HTML-элементов, которые соответствуют типам их содержимого и поведению в структуре веб-страницы &#8212; <b>блочные</b> и <b>строчные элементы</b>. С помощью блочных элементов можно создавать структуру веб-страницы, строчные элементы используются для форматирования текстовых фрагментов (за исключением элементов <kbd>&lt;area&gt;</kbd> и <kbd>&lt;img&gt;</kbd>). Разделение элементов на блочные и строчные используется в спецификации HTML до версии 4.01. В HTML5 эти понятия заменены более сложным набором категорий контента, согласно которым каждый HTML-элемент должен следовать правилам, определяющим, какой контент для него допустим. </p>
<h2 style="clear:both">Модель визуального форматирования CSS</h2>
<ul class="contents">
<li style="color:white; background:#84cd1b;">Содержание:</li>
<li><a href="#part1">1. Модель визуального форматирования</a></li>
<li><a href="#part2">2. Блочная модель</a></li>
<li><a href="#part3">3. Блочные элементы и блочные контейнеры</a></li>
<li><a href="#part4">4. Строчные элементы и строчные контейнеры</a></li>
<li><a href="#part5">5. Строчно-блочные элементы</a></li>
<li><a href="#part6">6. Как сделать строчный элемент блочным</a></li>
<li><a href="#part7">7. Схлопывание вертикальных отступов</a></li>
<li><a href="#part8">8. Отрицательные отступы</a></li>
<li><a href="#part9">9. Выпадание вертикальных отступов</a></li>
</ul>
<h3 id="part1">1. Модель визуального форматирования</h3>
<p>Модель визуального форматирования CSS представляет собой алгоритм, который обрабатывает HTML-документ и выводит его на экран устройства. Данная модель преобразует каждый элемент документа таким образом, что он генерирует ноль или более прямоугольных боксов в соответствии с блочной моделью CSS. Положение этих боксов на странице определяется следующими факторами:<br />
&#8212; размером элемента (с учётом того, заданы они явно или нет);<br />
&#8212; типом элемента (строчный или блочный);<br />
&#8212; схемой позиционирования (нормальный поток, позиционированные или плавающие элементы);<br />
&#8212; отношениями между элементами в DOM;<br />
&#8212; внутренними размерами содержащихся изображений;<br />
&#8212; внешней информацией (например, размеры окна браузера).</p>
<p>Положение и размеры бокса(ов) каждого элемента рассчитываются относительно краёв прямоугольной блока, так называемого <b>&#171;содержащего блока&#187;</b> (containing block). Размеры бокса не ограничиваются размерами содержащего блока, поэтому при определённых условиях он может выходить за его границы.</p>
<h3 id="part2">2. Блочная модель</h3>
<p>В блочной модели элемент рассматривается как прямоугольный контейнер, имеющий область содержимого и необязательные рамки и отступы (внутренние и внешние). Свойство <kbd>display</kbd> определяет тип контейнера элемента. Для каждого элемента существует значение браузера по умолчанию.</p>
<figure><img src="https://html5book.ru/wp-content/uploads/2015/07/box-model.png" alt="box-model" width="660" height="290" class="alignnone size-full wp-image-6283" srcset="https://html5book.ru/wp-content/uploads/2015/07/box-model.png 660w, https://html5book.ru/wp-content/uploads/2015/07/box-model-300x132.png 300w" sizes="(max-width: 660px) 100vw, 660px" /><figcaption>Рис. 1. Блочная модель элемента</figcaption></figure>
<p><b>Область содержимого</b> &#8212; это содержимое элемента, например, текст или изображение.</p>
<p><b>Внутренний отступ</b> задаётся свойством <kbd>padding</kbd>. Внутренний отступ &#8212; это расстояние между основным содержимым и его границей (рамкой). Если для элемента задать фон, то он распространится также и на поля элемента. Внутренний отступ не может принимать отрицательных значений, в отличие от внешнего отступа.</p>
<p><b>Внешний отступ</b> задаётся свойством <kbd>margin</kbd>. Он добавляет расстояние снаружи элемента от внешней границы рамки до соседних элементов, тем самым разделяя элементы на странице. Внешние отступы всегда остаются прозрачными и через них виден фон родительского элемента.</p>
<p>Значения <kbd>padding</kbd> и <kbd>margin</kbd> задаются в следующем порядке: верхнее, правое, нижнее и левое.</p>
<p><b>Граница</b>, или рамка элемента, задаётся с помощью свойства <kbd>border</kbd>. Если цвет рамки не задан, она принимает цвет основного содержимого элемента, например, текста. Если рамка имеет разрывы, то сквозь них будет проступать фон элемента.</p>
<p>Внешние, внутренние отступы и рамка элемента не являются обязательными, по умолчанию их значение равно нулю. Тем не менее, некоторые браузеры добавляют этим свойствам положительные значения по умолчанию на основе своих таблиц стилей. Очистить стили браузеров для всех элементов можно при помощи универсального селектора:</p>
<pre class="lang:css decode:true ">* {
 margin: 0;
 padding: 0;
 }</pre>
<h3 id="part3">3. Блочные элементы и блочные контейнеры</h3>
<p><b>Блочные элементы</b> &#8212; элементы высшего уровня, которые форматируются визуально как блоки, располагаясь на странице в окне браузера вертикально. Значения свойства <kbd>display</kbd>, такие как <kbd>block</kbd>, <kbd>list-item</kbd> и <kbd>table</kbd> делают элементы блочными. Блочные элементы генерируют основной блок, который содержит только блок элемента. Элементы со значением <kbd>display: list-item</kbd> генерируют дополнительные блоки для маркеров, которые позиционируются относительно основного блока. </p>
<p><kbd>&lt;address&gt;</kbd>, <kbd>&lt;article&gt;</kbd>, <kbd>&lt;aside&gt;</kbd>,<br />
<kbd>&lt;blockquote&gt;</kbd>,<br />
<kbd>&lt;dd&gt;</kbd>, <kbd>&lt;div&gt;</kbd>, <kbd>&lt;dl&gt;</kbd>, <kbd>&lt;dt&gt;</kbd>, <kbd>&lt;details&gt;</kbd>,<br />
<kbd>&lt;fieldset&gt;</kbd>, <kbd>&lt;figcaption&gt;</kbd>, <kbd>&lt;figure&gt;</kbd>, <kbd>&lt;footer&gt;</kbd>, <kbd>&lt;form&gt;</kbd>,<br />
<kbd>&lt;h1&gt;-&lt;h6&gt;</kbd>, <kbd>&lt;header&gt;</kbd>, <kbd>&lt;hr&gt;</kbd>,<br />
<kbd>&lt;iframe&gt;</kbd>,<br />
<kbd>&lt;li&gt;</kbd>, <kbd>&lt;legend&gt;</kbd>,<br />
<kbd>&lt;nav&gt;</kbd>, <kbd>&lt;noscript&gt;</kbd>,<br />
<kbd>&lt;ol&gt;</kbd>, <kbd>&lt;output&gt;</kbd>, <kbd>&lt;optgroup&gt;</kbd>, <kbd>&lt;option&gt;</kbd>,<br />
<kbd>&lt;p&gt;</kbd>, <kbd>&lt;pre&gt;</kbd>,<br />
<kbd>&lt;section&gt;</kbd>, <kbd>&lt;summary&gt;</kbd>,<br />
<kbd>&lt;table&gt;</kbd>,<br />
<kbd>&lt;ul&gt;</kbd></p>
<p>Блочные элементы могут размещаться непосредственно внутри элемента <kbd>&lt;body&gt;</kbd>. Они создают разрыв строки перед элементом и после него, образуя прямоугольную область, по ширине занимающую всю ширину веб-страницы или блока-родителя (если для элемента не задано значение <kbd>width</kbd>).</p>
<p>Свойства <kbd>width</kbd> и <kbd>height</kbd> устанавливают ширину и высоту области содержимого элемента. Фактическая ширина элемента складывается из ширины полей (внутренних отступов) <kbd>padding</kbd>, границ <kbd>border</kbd> и внешних отступов <kbd>margin</kbd>.</p>
<p>Блочные элементы могут содержать как строчные, так и блочные элементы, но не оба типа элементов сразу. При необходимости, строки текста, принадлежащие блочному контейнеру, могут быть обёрнуты анонимными контейнерами, которые будут вести себя внутри блока как элементы со значением <kbd>display: block;</kbd>, а строчные элементы обёрнуты элементом <kbd>&lt;p&gt;</kbd>. Блочные элементы могут содержаться только в пределах блочных элементов.</p>
<p>Элемент <kbd>&lt;p&gt;</kbd> относится к блочным элементам, но он не может содержать внутри себя другой элемент <kbd>&lt;p&gt;</kbd>, а также любой другой блочный элемент. </p>
<h4>Анонимные боксы уровня блока</h4>
<p>Как говорилось выше, блочные элементы могут содержать только блочные или только строчные элементы. В случае смешанного контента, когда блочный элемент одновременно содержит текстовое содержимое и другой блочный элемент, алгоритм визуального форматирования добавляет дополнительную обёртку для текстового содержимого &#8212; так называемый анонимный бокс. Поскольку такой контейнер не имеет названия, то к нему нельзя применить CSS-стили для оформления. Анонимные боксы наследуют свойства окружающего блока, а не наследуемые свойства принимают первоначальное значение.</p>
<figure><img src="https://html5book.ru/wp-content/uploads/2014/12/anonymous-block.png" alt="" width="680" height="113" class="alignnone size-full wp-image-10435" srcset="https://html5book.ru/wp-content/uploads/2014/12/anonymous-block.png 680w, https://html5book.ru/wp-content/uploads/2014/12/anonymous-block-300x50.png 300w" sizes="(max-width: 680px) 100vw, 680px" /><figcaption>Рис. 2. Анонимные боксы уровня блока</figcaption></figure>
<h3 id="part4">4. Строчные элементы и строчные контейнеры</h3>
<p><b>Встроенные (строчные) элементы</b> генерируют внутристрочные контейнеры. Они не формируют новые блоки контента. Значения свойства <kbd>display</kbd>, такие как <kbd>inline</kbd> и <kbd>inline-table</kbd> делают элементы строчными. </p>
<p><kbd>&lt;a&gt;</kbd>, <kbd>&lt;area&gt;</kbd>,<br />
<kbd>&lt;b&gt;</kbd>, <kbd>&lt;bdo&gt;</kbd>, <kbd>&lt;bdi&gt;</kbd>,<br />
<kbd>&lt;cite&gt;</kbd>, <kbd>&lt;code&gt;</kbd>,<br />
<kbd>&lt;dfn&gt;</kbd>, <kbd>&lt;del&gt;</kbd>,<br />
<kbd>&lt;em&gt;</kbd>,<br />
<kbd>&lt;i&gt;</kbd>, <kbd>&lt;img&gt;</kbd>, <kbd>&lt;ins&gt;</kbd>,<br />
<kbd>&lt;kbd&gt;</kbd>,<br />
<kbd>&lt;label&gt;</kbd>,<br />
<kbd>&lt;map&gt;</kbd>, <kbd>&lt;mark&gt;</kbd>,<br />
<kbd>&lt;s&gt;</kbd>, <kbd>&lt;samp&gt;</kbd>, <kbd>&lt;small&gt;</kbd>, <kbd>&lt;span&gt;</kbd>, <kbd>&lt;strong&gt;</kbd>, <kbd>&lt;sub&gt;</kbd>, <kbd>&lt;sup&gt;</kbd>,<br />
<kbd>&lt;time&gt;</kbd>,<br />
<kbd>&lt;q&gt;</kbd>,<br />
<kbd>&lt;ruby&gt;</kbd>,<br />
<kbd>&lt;u&gt;</kbd>,<br />
<kbd>&lt;var&gt;</kbd></p>
<p>Строчные элементы являются потомками блочных элементов. Они игнорируют верхние и нижние <kbd>margin</kbd> и <kbd>padding</kbd>, но если для элемента задан фон, он будет распространяться на верхний и нижний <kbd>padding</kbd>, заходя на соседние строки текста.</p>
<p>Ширина и высота строчного элемента зависит только от его содержимого, задать размеры с помощью CSS нельзя. Можно увеличить расстояние между соседними элементами по горизонтали с помощью горизонтальных полей и отступов.</p>
<p>Для того чтобы верхние и нижние поля и отступы работали для строчного элемента, нужно использовать конструкцию <kbd>{display: inline-block}</kbd>. Элемент останется встроенным, но к нему можно будет полноценно применить поля, отступы, задать ширину и высоту.</p>
<figure><img class="alignleft size-full wp-image-3259" src="https://html5book.ru/wp-content/uploads/2014/12/inline_elements.png" alt="inline_elements" width="680" height="510" srcset="https://html5book.ru/wp-content/uploads/2014/12/inline_elements.png 680w, https://html5book.ru/wp-content/uploads/2014/12/inline_elements-300x225.png 300w" sizes="(max-width: 680px) 100vw, 680px" /><figcaption>Рис. 3. Отличие воздействия CSS-свойств padding и margin на строчные и строчно-блочные элементы</figcaption></figure>
<p>Строчные элементы могут содержать только данные и другие строчные элементы. Исключение составляет элемент <kbd>&lt;a&gt;</kbd>, который согласно спецификации HTML5 может оборачивать целые абзацы, списки, таблицы, заголовки и целые разделы при условии, что они не содержат другие интерактивные элементы &#8212; другие ссылки и кнопки.</p>
<h4>Анонимные строчные боксы</h4>
<p>Любой текст, содержащийся непосредственно внутри блочного элемента и не внутри строчного элемента, рассматривается как анонимный строчный элемент. Также как и анонимные блочные боксы они наследуют свойства родительского блока, а не наследуемые свойства принимают первоначальное значение.</p>
<figure><img src="https://html5book.ru/wp-content/uploads/2014/12/anonymous-inline.png" alt="" width="680" height="56" class="alignnone size-full wp-image-10441" srcset="https://html5book.ru/wp-content/uploads/2014/12/anonymous-inline.png 680w, https://html5book.ru/wp-content/uploads/2014/12/anonymous-inline-300x25.png 300w" sizes="(max-width: 680px) 100vw, 680px" /><figcaption>Рис. 4. Анонимный строчный бокс</figcaption></figure>
<h3 id="part5">5. Строчно-блочные элементы</h3>
<p>Существует еще одна группа элементов, которые браузер обрабатывает как строчно-блочные <kbd>{display: inline-block;}</kbd>. Такие элементы являются встроенным, но для них можно задавать поля, отступы, ширину и высоту.<br />
<kbd>&lt;audio&gt;</kbd>,<br />
<kbd>&lt;button&gt;</kbd>,<br />
<kbd>&lt;canvas&gt;</kbd>,<br />
<kbd>&lt;embed&gt;</kbd>,<br />
<kbd>&lt;input&gt;</kbd>,<br />
<kbd>&lt;keygen&gt;</kbd>,<br />
<kbd>&lt;meter&gt;</kbd>,<br />
<kbd>&lt;object&gt;</kbd>,<br />
<kbd>&lt;progress&gt;</kbd>,<br />
<kbd>&lt;select&gt;</kbd>,<br />
<kbd>&lt;textarea&gt;</kbd>,<br />
<kbd>&lt;video&gt;</kbd>.</p>
<h3 id="part6">6. Как сделать строчный элемент блочным, а блочный &#8212; строчным</h3>
<p>В некоторых случаях бывает необходимо, чтобы строчный элемент вел себя как блочный и наоборот. Для этого необходимо установить соответствующее значение свойства <kbd>display</kbd>, например:</p>
<pre class="lang:css decode:true " >a {
display: block;
}/*превращаем строчный элемент в блочный, благодаря чему весь блок, а не только текст ссылки, становится ссылкой*/
div {
display: inline;
} /*превращаем блочный элемент в строчный*/</pre>
<p>В результате меняется только способ представления элемента браузером, при этом сам элемент свой тип не меняет.</p>
<h3 id="part7">7. Схлопывание вертикальных отступов</h3>
<p>Соприкасающиеся вертикальные отступы <kbd>margin</kbd> объединяются. При этом ширина общего отступа равна ширине большего из исходных отступов.</p>
<figure><img class="alignleft size-full wp-image-3253" src="https://html5book.ru/wp-content/uploads/2014/12/box_collapse.png" alt="box_collapse" width="680" height="425" srcset="https://html5book.ru/wp-content/uploads/2014/12/box_collapse.png 680w, https://html5book.ru/wp-content/uploads/2014/12/box_collapse-300x187.png 300w" sizes="(max-width: 680px) 100vw, 680px" /><figcaption>Рис. 5. Два блока до и после слияния отступов</figcaption></figure>
<p>Слияние выполняется только для блочных элементов в нормальном потоке документа. Внешние вертикальные отступы строчных, плавающих и абсолютно позиционированных элементов не сливаются.</p>
<p>Чтобы получить желаемый промежуток, можно задать, например, для верхнего элемента <kbd>padding-bottom</kbd>, а для нижнего элемента &#8212; <kbd>margin-top</kbd>.</p>
<p>Если среди схлопывающихся отступов есть отрицательные значения, то браузер добавит отрицательное значение к положительному, а полученный результат и будет расстоянием между элементами.</p>
<h3 id="part8">8. Отрицательные отступы</h3>
<p>Отрицательные отступы можно использовать, чтобы убрать пустые области между элементами. Например, необходимо расположить в ряд несколько элементов меню с заданными размерами. Для этого нужно задать для <kbd> li {display: inline-block;}</kbd>.</p>
<p><img class="alignleft size-full wp-image-3266" src="https://html5book.ru/wp-content/uploads/2014/12/menu_inline_block.png" alt="menu_inline_block" width="332" height="32" srcset="https://html5book.ru/wp-content/uploads/2014/12/menu_inline_block.png 332w, https://html5book.ru/wp-content/uploads/2014/12/menu_inline_block-300x28.png 300w" sizes="(max-width: 332px) 100vw, 332px" /></p>
<p style="clear: both;">Если нужно, чтобы элементы меню прилегали друг к другу, используем отрицательный <kbd>margin</kbd>:</p>
<pre class="lang:css decode:true ">li {
margin-right: -4px;
}
li {
border-top: 1px solid #888888;  /*Убираем двойные рамки между соседними элементами*/
border-bottom: 1px solid #888888;
border-left: 1px solid #888888;
}
li:last-child {
border-right: 1px solid #888888;
}</pre>
<p><img class="alignleft size-full wp-image-3267" src="https://html5book.ru/wp-content/uploads/2014/12/menu_inline_block_1.png" alt="menu_inline_block_1" width="317" height="32" srcset="https://html5book.ru/wp-content/uploads/2014/12/menu_inline_block_1.png 317w, https://html5book.ru/wp-content/uploads/2014/12/menu_inline_block_1-300x30.png 300w" sizes="(max-width: 317px) 100vw, 317px" /></p>
<h3 id="part9" style="clear: both;">9. Выпадание вертикальных отступов</h3>
<p>Если внутри одного блока расположить другой блок и задать ему <kbd>margin-top</kbd>, то внутренний блок прижмется к верхнему краю родительского, а у родительского элемента появится отступ сверху, т.е. внутренний блок &#171;выпадет&#187; из родительского блока. Если у родительского элемента также был задан верхний отступ, то выберется наибольшее из значений.</p>
<p>Чтобы избавиться от эффекта выпадания, можно задать родительскому элементу <kbd>padding-top</kbd> или добавить <kbd>border-top: 1px solid transparent</kbd>.</p>       
                        
                        
                        
                        
                        <h2>CSS позиционирование</h2>
                        
                        Для вёрстки страниц часто используются два основных инструмента &#8212; <em>позиционирование (positioning)</em> и <em>свободное перемещение (floating)</em>. CSS-позиционирование позволяет указать, где появится блок элемента, а свободное перемещение перемещает элементы к левому или правому краю блока-контейнера, позволяя остальному содержимому &#171;обтекать&#187; его.</p>
<h2 style="clear:both">Позиционирование и свободное перемещение элементов</h2>
<ul class="contents">
<li style="color:white; background:#84cd1b;">Содержание:</li>
<li><a href="#position">1. Типы позиционирования</a></li>
<li><a href="#position-prop">2. Свойства смещения</a></li>
<li><a href="#part3">3. Позиционирование внутри элемента</a></li>
<li><a href="#part4">4. Проблемы позиционирования</a></li>
<li><a href="#float">5. Свободное перемещение элементов</a></li>
<li><a href="#part6">6. Отмена обтекания элементов</a></li>
</ul>
<h3 id="position">1. Типы позиционирования</h3>
<p>Свойство <kbd>position</kbd> позволяет точно задать новое местоположение блока относительно того места, где он находился бы в нормальном потоке документа. По умолчанию все элементы располагаются последовательно один за другим в том порядке, в котором они определены в структуре HTML-документа. Свойство не наследуется.</p>
<table class="t1">
<tr>
<th colspan="2">position</th>
</tr>
<tr>
<td>Значение:</td>
<td></td>
</tr>
<tr>
<td><kbd>static</kbd></td>
<td>Значение по умолчанию, означает отсутствие позиционирования. Элементы отображаются последовательно один за другим в том порядке, в котором они определены в HTML-документе. Используется для очистки любого другого значения позиционирования.</td>
</tr>
<tr>
<td><kbd>relative</kbd></td>
<td>Относительно позиционированный элемент сдвигается со своего обычного места в разных направлениях относительно границ родительского контейнера, а пространство, которое он занимал, не исчезает. При этом такой элемент может перекрывать другое содержимое на странице. </p>
<p>Если для относительно позиционированного элемента одновременно задать свойства <kbd>top</kbd> и <kbd>bottom</kbd> или <kbd>left</kbd> и <kbd>right</kbd>, то в первом случае сработает только <kbd>top</kbd>, во втором &#8212; <kbd>left</kbd>.</p>
<p>Относительное позиционирование позволяет задавать <kbd>z-index</kbd> для элемента, а также абсолютно позиционировать дочерние элементы внутри блока.</td>
</tr>
<tr>
<td><kbd>absolute</kbd></td>
<td>Абсолютно позиционированный элемент полностью удаляется из потока документа и позиционируется относительно границ его блока-контейнера (другого элемента или окна браузера). Блок-контейнер для абсолютно позиционированного элемента &#8212; ближайший элемент-предок, значение свойства <kbd>position</kbd> которого не равно <kbd>static</kbd>. </p>
<p>Местоположение краёв элемента определяется с помощью свойств смещения. Пространство, которое занимал такой элемент, схлопывается, как будто элемента не существовало на странице. Абсолютно позиционированный элемент может перекрывать другие элементы или быть перекрытым ими (за счёт свойства <kbd>z-index</kbd>). Любой абсолютно позиционированный элемент генерирует блок, то есть принимает значение <kbd>display: block;</kbd>.</td>
</tr>
<tr>
<td><kbd>fixed</kbd></td>
<td>Фиксирует элемент в указанном месте страницы. Блоком-контейнером фиксированного элемента является окно просмотра, то есть элемент всегда фиксируется относительно окна браузера и не меняет своего положения во время прокрутки страницы. Сам элемент при этом полностью удаляется из основного потока документа и создаётся в новом потоке документа.</td>
</tr>
<tr>
<td><kbd>initial</kbd></td>
<td>Устанавливает значение свойства в значение по умолчанию.</td>
</tr>
<tr>
<td><kbd>inherit</kbd></td>
<td>Наследует значение свойства от родительского элемента.</td>
</tr>
</table>
<figure><img src="https://html5book.ru/wp-content/uploads/2014/11/static-relative-absolute.png" alt="static-relative-absolute" width="680" height="324" class="alignnone size-full wp-image-9887" srcset="https://html5book.ru/wp-content/uploads/2014/11/static-relative-absolute.png 680w, https://html5book.ru/wp-content/uploads/2014/11/static-relative-absolute-300x143.png 300w" sizes="(max-width: 680px) 100vw, 680px" /><figcaption>Рис. 1. Разница между статичным, относительным и абсолютным позиционированием</figcaption></figure>
<h3 id="position-prop">2. Свойства смещения</h3>
<p>Свойства описывают смещение относительно ближайшей стороны блока-контейнера. Задаются для элементов, для которых значение свойства <kbd>position</kbd> не равно <kbd>static</kbd>. Могут принимать как положительные, так и отрицательные значения. Не наследуются.</p>
<table class="t1">
<tr>
<th colspan="2">top, right, bottom, left</th>
</tr>
<tr>
<td>Значение:</td>
<td></td>
</tr>
<tr>
<td><kbd>auto</kbd></td>
<td>Значение по умолчанию. Вычисляемое значение свойства равно нулю.</td>
</tr>
<tr>
<td>длина</td>
<td>Смещение задаётся в единицах длины.</td>
</tr>
<tr>
<td><kbd>%</kbd></td>
<td>Процентные значения вычисляются относительно высоты блока-контейнера для <kbd>top</kbd> и <kbd>bottom</kbd> и ширины блока-контейнера для <kbd>right</kbd> и <kbd>left</kbd>.</td>
</tr>
<tr>
<td><kbd>initial</kbd></td>
<td>Устанавливает значение свойства в значение по умолчанию.</td>
</tr>
<tr>
<td><kbd>inherit</kbd></td>
<td>Наследует значение свойства от родительского элемента.</td>
</tr>
</table>
<p>Для свойства <kbd>top</kbd> положительные значения перемещают верхний край позиционируемого элемента ниже, а отрицательные &#8212; выше верхнего края его блока-контейнера. Для свойства <kbd>left</kbd> положительные значения сдвигают край позиционируемого элемента вправо, а отрицательные значения &#8212; влево. То есть, положительные значения смещают элемент внутрь блока-контейнера, а отрицательные &#8212; за его пределы.</p>
<h3 id="part3">3. Позиционирование внутри элемента</h3>
<p>Для блока-контейнера абсолютно позиционированного элемента задаётся свойство <kbd>position: relative</kbd> без смещений. Это позволяет позиционировать элементы внутри элемента-контейнера.</p>
<pre class="lang:default decode:true ">&lt;div class="wrap"&gt;
  &lt;div class="white"&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
<pre class="lang:css decode:true ">.wrap {
  padding: 10px;
  height: 150px;
  position: relative;
  background: #e7e6d4;
  text-align: right;
  border: 3px dashed #645a4e;
}
.white {
  position: absolute; 
  width: 200px;
  top: 10px; 
  left: 10px;
  padding: 10px;
  background: #ffffff; 
  border: 3px dashed #312a22;
}</pre>
<figure><img src="https://html5book.ru/wp-content/uploads/2014/11/relative-absolute.png" alt="relative-absolute" width="680" height="165" class="alignleft size-full wp-image-3122" srcset="https://html5book.ru/wp-content/uploads/2014/11/relative-absolute.png 680w, https://html5book.ru/wp-content/uploads/2014/11/relative-absolute-300x72.png 300w" sizes="(max-width: 680px) 100vw, 680px" /><figcaption>Рис. 2. Абсолютное относительное позиционирование</figcaption></figure>
<h3 id="part4">4. Проблемы позиционирования</h3>
<p>1. Если ширине или высоте абсолютно позиционированного элемента присвоено значение <kbd>auto</kbd>, то её значение будет определяться шириной или высотой содержимого элемента. Если ширина или высота объявлена явно, то именно это значение и будет присвоено.<br />
2. Если внутри блока с <kbd>position: absolute</kbd> расположены элементы, для которых задано обтекание <kbd>float</kbd>, то высота этого элемента будет равна высоте самого высокого из этих элементов.<br />
3. Для элемента с <kbd>position: absolute</kbd> или <kbd>position: fixed</kbd> нельзя одновременно устанавливать свойство <kbd>float</kbd>, а для элемента с <kbd>position: relative</kbd> &#8212; можно.<br />
4. Если предок позиционированного элемента является блочным элементом, то блок-контейнер формируется областью содержимого, ограниченной рамкой (<kbd>border</kbd>). Если предок &#8212; строковый элемент, блок-контейнер формируется внешней границей его содержимого. Если предка нет, блоком-контейнером является элемент <kbd>body</kbd>.</p>
<h3 id="float">5. Свободное перемещение элементов</h3>
<p>В обычном порядке блочные элементы отображаются, начиная с верхнего края окна браузера по направлению к нижнему краю. Свойство <kbd>float</kbd> позволяет перемещать любой элемент, выравнивая его по левому или правому краю веб-страницы или содержащего его элемента-контейнера. При этом остальные блочные элементы будут его игнорировать, а строчные элементы будут смещаться вправо или влево, освобождая для него пространство и обтекая его. </p>
<figure><img src="https://html5book.ru/wp-content/uploads/2014/11/float.png" alt="float" width="680" height="425" class="alignleft size-full wp-image-3154" srcset="https://html5book.ru/wp-content/uploads/2014/11/float.png 680w, https://html5book.ru/wp-content/uploads/2014/11/float-300x187.png 300w" sizes="(max-width: 680px) 100vw, 680px" /><figcaption>Рис. 3. Свободное перемещение элементов</figcaption></figure>
<p>Плавающий блок принимает размеры своего содержимого с учетом внутренних отступов и рамок. Верхние и нижние отступы <kbd>margin</kbd> плавающих элементов не схлопываются. Свойство <kbd>float</kbd> применяется как к блочным элементам, так и к строчным элементам. </p>
<p>Левый или правый внешний край перемещаемого элемента, в отличие от позиционированных элементов, не может располагаться левее (или правее) внутреннего края его блока-контейнера, т.е. выходить за его границы. При этом, если для блока-контейнера заданы внутренние отступы, то плавающий блок будет отстоят от края блока-контейнера на заданное расстояние.</p>
<p>Свойство автоматически изменяет вычисляемое (отображаемое в браузере) значение свойства <kbd>display</kbd> на <kbd>display: block</kbd> для следующих значений: <kbd>inline</kbd>, <kbd>inline-block</kbd>, <kbd>table-row</kbd>, <kbd>table-row-group</kbd>, <kbd>table-column</kbd>, <kbd>table-column-group</kbd>, <kbd>table-cell</kbd>, <kbd>table-caption</kbd>, <kbd>table-header-group</kbd>, <kbd>table-footer-group</kbd>. Значение <kbd>inline-table</kbd> меняет на <kbd>table</kbd>.</p>
<p>Свойство не оказывает никакого влияния на элементы с <kbd>display: flex</kbd> и <kbd>display: inline-flex</kbd>.</p>
<table class="t1">
<tr>
<th colspan="2">float</th>
</tr>
<tr>
<td>Значение:</td>
<td></td>
</tr>
<tr>
<td><kbd>none</kbd></td>
<td>Значение по умолчанию. Также отменяет любое перемещение для элемента из группы элементов, для которых уже установлено обтекание.</td>
</tr>
<tr>
<td><kbd>left</kbd></td>
<td>Элемент изымается из нормального потока элементов и позиционируется по левому краю блока-контейнера.</td>
</tr>
<tr>
<td><kbd>right</kbd></td>
<td>Элемент позиционируется по правому краю блока-контейнера.</td>
</tr>
<tr>
<td><kbd>initial</kbd></td>
<td>Устанавливает значение свойства в значение по умолчанию.</td>
</tr>
<tr>
<td><kbd>inherit</kbd></td>
<td>Наследует значение свойства от родительского элемента.</td>
</tr>
</table>
<p>При использовании свойства <kbd>float</kbd> для блочных элементов обязательно задавать ширину. Тем самым браузер создаст место для другого содержимого. Но если совокупная ширина всех столбцов окажется больше доступного места, то последний элемент спустится вниз.</p>
<p>При этом вертикальные отступы <kbd>margin</kbd> обтекаемых элементов не схлопываются с отступами соседних элементов, в отличие от обычных блочных элементов.</p>
<h3 id="part6">6. Отмена обтекания элементов</h3>
<h4 id="clear">6.1. Свойство clear</h4>
<p>Свойство <kbd>clear</kbd> определяет, как будет располагаться элемент, идущий следом за плавающим элементом. Свойство отменяет обтекание с одной или обоих сторон элемента, установленное свойством <kbd>float</kbd>. Для предотвращения отображение фона или границ под плавающими элементами используется правило <kbd>{overflow: hidden;}</kbd>.</p>
<table class="t1">
<tr>
<th colspan="2">clear</th>
</tr>
<tr>
<td>Значение:</td>
<td></td>
</tr>
<tr>
<td><kbd>left</kbd></td>
<td>Отменяет обтекание по левой стороне, смещая элемент вниз. Правое обтекание остается в силе.</td>
</tr>
<tr>
<td><kbd>right</kbd></td>
<td>Отменяет обтекание по правой стороне, смещая элемент вниз. Левое обтекание остается в силе.</td>
</tr>
<tr>
<td><kbd>both</kbd></td>
<td>Отменяет обтекание с обеих сторон элемента, смещая его вниз.</td>
</tr>
<tr>
<td><kbd>none</kbd></td>
<td>Значение по умолчанию. Также отменяет очистку обтекания, установленное для элементов одной группы.</td>
</tr>
<tr>
<td><kbd>initial</kbd></td>
<td>Устанавливает значение свойства в значение по умолчанию.</td>
</tr>
<tr>
<td><kbd>inherit</kbd></td>
<td>Наследует значение свойства от родительского элемента.</td>
</tr>
</table>
<h4>6.2. Очистка потока стилями при помощи класса clearfix и псевдокласса :after</h4>
<p>Предположим, имеется блок-контейнер, для которого не заданы ширина и высота. Внутри него помещен плавающий блок с заданными размерами.</p>
<pre class="lang:default decode:true ">&lt;div class="container"&gt;
    &lt;div class="floatbox"&gt;
    &lt;/div&gt;
&lt;/div&gt;</pre>
<pre class="lang:css decode:true ">.container {
  padding: 20px;
  background: #e7e6d4;
  border: 3px dashed #645a4e;
}
.floatbox {
  float: left;
  width: 300px;
  height: 150px;
  margin-right: 20px;
  padding: 0 20px;
  background: #ffffff;
  border: 3px dashed #666666;
}</pre>
<figure><img src="https://html5book.ru/wp-content/uploads/2014/11/float1.png" alt="float1" width="682" height="185" class="alignleft size-full wp-image-3112" srcset="https://html5book.ru/wp-content/uploads/2014/11/float1.png 682w, https://html5book.ru/wp-content/uploads/2014/11/float1-300x81.png 300w" sizes="(max-width: 682px) 100vw, 682px" /><figcaption>Рис. 4. &#171;Эффект схлопывания&#187; блока-контейнера</figcaption></figure>
<p><b>Решение проблемы:</b><br />
Создаем класс <kbd>.clearfix</kbd> и в сочетании с псевдоклассом <kbd>:after</kbd> применяем его к блоку-контейнеру.</p>
<pre class="lang:default decode:true ">&lt;div class="container clearfix"&gt;
  &lt;div class="floatbox"&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
<pre class="lang:css decode:true ">.container {
  padding: 20px;
  background: #e7e6d4;
  border: 3px dashed #645a4e;
}
.floatbox {
  float: left;
  width: 300px;
  height: 150px;
  margin-right: 20px;
  padding: 0 20px;
  background: #ffffff;
  border: 3px dashed #666666;
}
.clearfix:after {
  content: "";
  display: block;
  height: 0;
  clear: both;
  visibility: hidden;
}</pre>
<p><b>Второй вариант очистки потока:</b></p>
<pre>.clearfix:after {
  content: "";
  display: table;
  clear: both;
}</pre>
<figure><img src="https://html5book.ru/wp-content/uploads/2014/11/float2.png" alt="float2" width="680" height="207" class="alignleft size-full wp-image-3114" srcset="https://html5book.ru/wp-content/uploads/2014/11/float2.png 680w, https://html5book.ru/wp-content/uploads/2014/11/float2-300x91.png 300w" sizes="(max-width: 680px) 100vw, 680px" /><figcaption>Рис. 5. Применение &#171;очищающего&#187; метода для блока-контейнера, содержащего плавающий элемент</figcaption></figure>
<h4>6.3. Легкий способ очистки потока</h4>
<p>Существует ещё один прием очистки потока для элемента, содержащего плавающие элементы, например, для маркированного горизонтального списка:</p>
<pre>&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;</pre>
<pre class="lang:css decode:true " >ul {
  margin: 0;
  list-style: none;
  padding: 20px;
  background: #e7e6d4;
  overflow: auto;
}
li {
  float: left;
  width: calc(100% / 3 - 20px);
  height: 50px;
  margin-right: 20px;
  background: #ffffff;
  border: 3px dashed #666666;
}
li:last-child {margin-right: 0;}</pre>
<figure><img src="https://html5book.ru/wp-content/uploads/2014/11/ul-overflow.png" alt="ul-overflow" width="660" height="103" class="alignleft size-full wp-image-6287" srcset="https://html5book.ru/wp-content/uploads/2014/11/ul-overflow.png 660w, https://html5book.ru/wp-content/uploads/2014/11/ul-overflow-300x47.png 300w" sizes="(max-width: 660px) 100vw, 660px" /><figcaption>Рис. 6. Очистка потока горизонтального списка</figcaption></figure>
                        
                        
                        
                            <br><br><br><br><br><br></div></div> </div> 
                            
                            <div class="container">
                      <div class="bubble">
                        <div class="info">
                        
                        <h2>CSS разное</h2>
                        
                        <p align="center"><a class="button1" href="text.html"><strong>CSS Текст</strong></a></p>
                        <p align="center"><a class="button1" href="shrift.html"><strong>CSS Шрифты</strong></a></p>
                        <p align="center"><a class="button1" href="href.html"><strong>CSS Ссылки</strong></a></p>
                        <p align="center"><a class="button1" href="table.html"><strong>CSS Таблицы</strong></a></p>
                        <p align="center"><a class="button1" href="spiski.html"><strong>CSS Списки</strong></a></p>
                        <p align="center"><a class="button1" href="fon.html"><strong>CSS Фон</strong></a></p>
                        <p align="center"><a class="button1" href="ramka.html"><strong>CSS Рамка</strong></a></p>
                        <p align="center"><a class="button1" href="content.html"><strong>CSS Контент</strong></a></p>
                        <p align="center"><a class="button1" href="color.html"><strong>CSS Цвета</strong></a></p>
                        <p align="center"><a class="button1" href="gradient.html"><strong>CSS Градиент</strong></a></p>
                        <p align="center"><a class="button1" href="tenblocka.html"><strong>CSS Тень блока</strong></a></p>
                        <p align="center"><a class="button1" href="perehodi.html"><strong>CSS Переходы</strong></a></p>
                        <p align="center"><a class="button1" href="transform.html"><strong>CSS Трансформация / 3D трансофрмация</strong></a></p>
                        <p align="center"><a class="button1" href="animation.html"><strong>CSS Анимация</strong></a></p>
                        <p align="center"><a class="button1" href="flexbox.html"><strong>CSS Felxbox</strong></a></p>
                        <p align="center"><a class="button1" href="columns.html"><strong>CSS Columns</strong></a></p>
                        <p align="center"><a class="button1" href="media.html"><strong>CSS Медиа запросы</strong></a></p>
                        <p align="center"><a class="button1" href="filters.html"><strong>CSS Фильтры</strong></a></p>
                        
                        
                        
                        
                        <br><br><h2>Полный справочник по CSS + свойства и онлайн генератор</h2>
                        <p align="center"><a class="button1" href="generator.html"><strong>CSS Генераторы</strong></a></p>
                        <p align="center"><a class="button1" href="https://html5book.ru/css-spravochnik.html" target="_blank"><strong>Справочник CSS (полный список)</strong></a></p>
                        <p align="center"><a class="button1" href="https://html5book.ru/category/css-svoystva/" target="_blank"><strong>Свойства CSS (полный список)</strong></a></p>
                        
                        
                        
                        
                        
                        
                        <br><br><br><br><br><br></div></div></div>
      
      
      
      
      <a href="#" title="Вернуться к началу" class="topbutton">Наверх</a>
      
     
    <br><br><br><br><br><br><br><br><br><br><br><br><br><br></body>
                <footer class="footer" align="center"><br><br>
	           Restart72 &copy;2017 Дмитрий Сидоров (Казанцев) | Open Source Project ||| Материалы взяты с сайта <a href="https://html5book.ru">HTML5BOOK.RU</a>
        </footer>
    </head>
</html>